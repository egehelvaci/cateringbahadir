generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id      Int @id @default(autoincrement())
  name    String
  users   User[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id         Int  @id @default(autoincrement())
  companyId  Int
  email      String  @unique
  name       String?
  password   String
  company    Company @relation(fields: [companyId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GoogleAccount {
  id              Int      @id @default(autoincrement())
  email           String   @unique
  accessToken     String
  refreshToken    String
  scope           String?
  tokenType       String?  @default("Bearer")
  expiryDate      Int?     // ms epoch
  historyId       String?  // incremental sync için
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model InboundEmail {
  id          Int       @id @default(autoincrement())
  messageId   String?   @unique
  fromAddr    String?
  subject     String?
  receivedAt  DateTime?
  raw         String?   @db.Text
  gmailId     String?   // Gmail message id
  threadId    String?   // Gmail thread id
  labelIds    Json?     // Gmail labels
  historyId   String?   // Gmail history id
  createdAt   DateTime  @default(now())
}

model MicrosoftAccount {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  accessToken  String
  refreshToken String?
  scope        String
  expiryDate   DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([email])
  @@index([expiryDate])
}

model Order {
  id          Int           @id @default(autoincrement())
  orderNumber String        @unique
  customerName String
  customerPhone String?
  totalAmount Float?
  status      OrderStatus   @default(PENDING)
  notes       String?
  items       OrderItem[]
  qrScans     QRScan[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@index([status])
  @@index([orderNumber])
}

model OrderItem {
  id          Int       @id @default(autoincrement())
  orderId     Int
  qrCode      String    @unique // Her item'ın benzersiz QR kodu
  productName String
  quantity    Int
  price       Float?
  firstScanAt DateTime? // İlk okutma zamanı
  secondScanAt DateTime? // İkinci okutma zamanı
  order       Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  qrScans     QRScan[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([orderId])
  @@index([qrCode])
}

model QRScan {
  id          Int       @id @default(autoincrement())
  orderId     Int
  orderItemId Int
  employeeId  Int?      // Okutmayı yapan çalışan
  qrCode      String
  scanType    Int       // 1: İlk okutma (hazırlama), 2: İkinci okutma (teslimat)
  scannedBy   String?   // Kim tarafından okutuldu (eski alan, geriye uyumluluk için)
  scannedAt   DateTime  @default(now())
  
  order       Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  employee    Employee? @relation(fields: [employeeId], references: [id])
  
  @@index([orderId])
  @@index([orderItemId])
  @@index([qrCode])
  @@index([employeeId])
}

model Employee {
  id          Int       @id @default(autoincrement())
  name        String
  email       String?   @unique
  phone       String?
  department  String?   // Hazırlama, Teslimat, vb.
  isActive    Boolean   @default(true)
  qrScans     QRScan[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([department])
  @@index([isActive])
}

enum OrderStatus {
  PENDING       // Beklemede
  CONFIRMED     // Onaylandı
  READY         // Hazır (tüm QR'lar ilk kez okutuldu)
  DELIVERED     // Teslim edildi (tüm QR'lar ikinci kez okutuldu)
  CANCELLED     // İptal edildi
}

// Gemi-Yük Eşleştirme Modelleri
model Vessel {
  id            Int         @id @default(autoincrement())
  name          String
  dwt           Float       // metric tons
  grainCuft     Float?      // cubic feet
  baleCuft      Float?      // cubic feet
  speedKnots    Float       @default(12.0)
  features      Json?       // ["box", "open_hatch", "geared", etc.]
  currentPort   String?
  laycanStart   DateTime?
  laycanEnd     DateTime?
  status        VesselStatus @default(AVAILABLE)
  sourceEmailId Int?        // Hangi emailden parse edildi
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  matches       VesselCargoMatch[]
  
  @@index([status])
  @@index([laycanStart, laycanEnd])
  @@index([currentPort])
}

model Cargo {
  id                  Int         @id @default(autoincrement())
  reference           String      // Yük referansı/açıklaması
  loadPort            String
  laycanStart         DateTime
  laycanEnd           DateTime
  quantity            Float       // metric tons
  stowageFactorValue  Float?
  stowageFactorUnit   String      @default("cuft/mt") // "cuft/mt" veya "m3/mt"
  brokenStowagePct    Float       @default(5.0)
  requirements        Json?       // ["box", "open_hatch", etc.]
  status              CargoStatus @default(AVAILABLE)
  sourceEmailId       Int?        // Hangi emailden parse edildi
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  
  matches             VesselCargoMatch[]
  
  @@index([status])
  @@index([laycanStart, laycanEnd])
  @@index([loadPort])
}

model VesselCargoMatch {
  id              Int             @id @default(autoincrement())
  vesselId        Int
  cargoId         Int
  matchScore      Float           // Eşleşme skoru (0-100)
  matchReasons    Json            // Detaylı eşleşme bilgileri
  status          MatchStatus     @default(PROPOSED)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  vessel          Vessel          @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  cargo           Cargo           @relation(fields: [cargoId], references: [id], onDelete: Cascade)
  
  @@unique([vesselId, cargoId])
  @@index([status])
  @@index([matchScore])
}

model Port {
  id          BigInt    @id @default(autoincrement())
  name        String    @unique
  alternateNames Json?  // ["Chornomorsk", "Illichivsk", etc.]
  country     String
  latitude    Float
  longitude   Float
  type        String?   // "seaport", "river", etc.
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([name])
  @@index([country])
}

enum VesselStatus {
  AVAILABLE
  FIXED      // Sabitlendi
  INACTIVE
  BALLAST    // Mevcut değer - korunuyor
  LOADING    // Mevcut değer - korunuyor
  DISCHARGING // Mevcut değer - korunuyor
  MAINTENANCE // Mevcut değer - korunuyor
}

enum CargoStatus {
  AVAILABLE
  FIXED      // Sabitlendi
  CANCELLED
  OPEN       // Mevcut değer - korunuyor
  FAILED     // Mevcut değer - korunuyor
  ON_SUBJECTS // Mevcut değer - korunuyor
}

enum MatchStatus {
  PROPOSED   // Önerilen
  ACCEPTED   // Kabul edildi
  REJECTED   // Reddedildi
  EXPIRED    // Süresi doldu
  SUGGESTED  // Mevcut değer - korunuyor
  REVIEWED   // Mevcut değer - korunuyor
  CONTACTED  // Mevcut değer - korunuyor
  NEGOTIATING // Mevcut değer - korunuyor
}
